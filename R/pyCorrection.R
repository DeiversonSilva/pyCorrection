#' Polygon Correction
#'
#' Fix the sobreposition of geometries in a shapefile based in an control shapefile
#' @param shapeToCorrect The path of the shapefile to correct
#' @param shapeControl The path of the control shapefile used to correct the bugged shapefile
#' @param pathToSave Path to save the new shapefile
#' @param nameToSaveNewShapefile The name of the new shapefile generated by the correction
#' @return The new shapefile fixed by the code
#' @examples
#' shspefileCorrected <- carCorrection("C:/r/municipios.shp", "C:/r/controle_incra.shp", "ShapefileCorrected");
#' @export

pyCorrection <- function(shapeToCorrect, shapeControl, pathToSave, nameToSaveNewShapefile){

  ################ LOADING THE SHAPEFILE #####################
  # Initiate the libraries
  library(maptools)
  library(maps)
  library(rgdal)
  library(ggplot2)
  library(raster)
  library(sp)
  library(foreach)
  library(rgeos)
  library(spdep)

  # Reading the shapefiles
  shapefileOriginal <- readOGR(shapeToCorrect);
  controle <- readOGR(shapeControl);

  # The control Shapefile receives a new column to identify the control
  controle$col_control = 1:nrow(controle);

  # adding a value to the control column
  i = 1;
  foreach(controle) %do%{

    controle$controle = 1;
    i = i + 1;
  }

  # Plot the loaded shapefiles
  #plot(shapefileOriginal);
  #plot(controle);

  # Transform the projection system from the control shapefile to the same of the shapefile who will be fixed
  controle <- spTransform(controle, proj4string(shapefileOriginal));

  # Bind the two shapefiles
  mapa <- bind(controle, shapefileOriginal);
  plot(mapa);

  ###########################################################################
  # Function to check if the point of a polygon is overlaping another polygon
  ###########################################################################

  verifyPointInPolygon <- function(px, py, poligonoAVerificar){

    # Check how many point there is in the polygon
    pontosPoligono = (length(mapa@polygons[[poligonoAVerificar]]@Polygons[[1]]@coords) / 2) - 1;

    # Verify the minimum value of x
    a = 1;
    Xmin = '';
    foreach(p=1:pontosPoligono) %do% {

      if(Xmin == '' || Xmin >  mapa@polygons[[poligonoAVerificar]]@Polygons[[1]]@coords[a,1]){
        Xmin = mapa@polygons[[poligonoAVerificar]]@Polygons[[1]]@coords[a,1];
      }
      a = a+1;
    }

    # Verify the maximum value of x
    a = 1;
    Xmax = '';
    foreach(p=1:pontosPoligono) %do% {

      if(Xmax == '' || Xmax < mapa@polygons[[poligonoAVerificar]]@Polygons[[1]]@coords[a,1]){
        Xmax = mapa@polygons[[poligonoAVerificar]]@Polygons[[1]]@coords[a,1];
      }
      a = a+1;
    }


    # Verify the minimum value of y
    a = 1;
    Ymin = '';
    foreach(p=1:pontosPoligono) %do% {

      if(Ymin == '' || Ymin >  mapa@polygons[[poligonoAVerificar]]@Polygons[[1]]@coords[a,2]){
        Ymin = mapa@polygons[[poligonoAVerificar]]@Polygons[[1]]@coords[a,2];
      }
      a = a+1;
    }

    # Verify the maximum value of y
    a = 1;
    Ymax = '';
    foreach(p=1:pontosPoligono) %do% {

      if(Ymax == '' || Ymax < mapa@polygons[[poligonoAVerificar]]@Polygons[[1]]@coords[a,2]){
        Ymax = mapa@polygons[[poligonoAVerificar]]@Polygons[[1]]@coords[a,2];
      }
      a = a+1;
    }

    # p is your point, p.x is the x coord, p.y is the y coord
    if (px < Xmin || px > Xmax || py < Ymin || py > Ymax) {

      # Definitely not within the polygon!
      return(FALSE)
    } else{

      # Is in the polygon
      return(TRUE)
    }

  }

  ###########################################################################
  # Script to find the knear neighbor
  ###########################################################################

  # Find the neighbours... If you don't use the row.names part, the elements
  # of the list will be numbered from 0
  polnb <- poly2nb(mapa, row.names = 1:length(mapa));

  # The coordinates function applied to a SpatialPolygons object will return
  # the coordinates of the centroids
  text(coordinates(mapa), labels = 1:length(mapa), pos = 3);

  # Plot the polygons who have a relatioship by line or dots in comum
  plot(polnb, coordinates(mapa), pch = 16, col = "blue", add = TRUE);

  # Description of the map elements
  summary(polnb);

  # Verify if the polygons are symmetryc
  knb <- knn2nb(knearneigh(coordinates(mapa), k = 4));
  is.symmetric.nb(knb);

  # Froces the symmetry betwen the polygons
  knb2 <- make.sym.nb(knb);
  is.symmetric.nb(knb2);

  # Ploting a non symmetrical map
  plot(knb, coordinates(mapa), pch = 16, col = "blue", arrows = TRUE, add = TRUE);

  # Ploting a map with forced symmetryc
  plot(knb2, coordinates(mapa), pch = 16, col = "blue", arrows = TRUE, add = TRUE);


  ###########################################################################
  # Verify all the polygons in a shapefile and fix the overlaps
  ###########################################################################

  #polnb <- poly2nb(mapa, row.names = 1:length(mapa));
  #plot(mapa);
  #text(coordinates(mapa), labels = 1:length(mapa), pos = 3);

  # Initializing the variables
  pontosSobrepostos <- matrix(c(111111.1,111111.1), nrow=1, ncol=2);
  elementosMapa = knb;
  countPoligonosSobrepostos = 0;
  iteradorElementosMapa= 1;
  pontosTotaisSobrepostos = 0;
  countOverlap = 0;
  total = length(elementosMapa);
  pb <- winProgressBar(title = "progress bar", min = 0, max = total, width = 300);

  # Foreach in all the elements of the shapefile
  foreach(elementosMapa) %do%{

    poligonoSobreposto = FALSE;
    vizinhos = elementosMapa[[iteradorElementosMapa]];
    valor = (length(mapa@polygons[[iteradorElementosMapa]]@Polygons[[1]]@coords) / 2) -1;
    iteradorPontosPoligono = 1;
    listaVizinhosSobrepostos = vector();

    # Foreach in all the neighbors
    foreach(1:valor) %do% {

      iteradorVizinhos = 1;
      cor = 'green';
      pontosSobrepostos = 0;
      totalVizinhos = (length(vizinhos));

      # Foreach in all the points of each polygon
      foreach(1:totalVizinhos) %do%{

        pointX = mapa@polygons[[iteradorElementosMapa]]@Polygons[[1]]@coords[iteradorPontosPoligono,1];
        pointY = mapa@polygons[[iteradorElementosMapa]]@Polygons[[1]]@coords[iteradorPontosPoligono,2];

        poligonoAVerificar = vizinhos[iteradorVizinhos];

        # Call the function to check the overlaps
        if(!is.null(poligonoAVerificar)){
          results = verifyPointInPolygon(pointX, pointY, poligonoAVerificar);
        }

        if(results == TRUE){
          #print('point overlaping the polygon');
          #print(pointX);
          #print(pointY);
          #points(pointX, pointY, col = "red", cex = 1.6);
          cor = 'red';
          pontosSobrepostos = 1;
          poligonoSobreposto = TRUE;
          vizinhoAtual = poligonoAVerificar;

          if(!vizinhoAtual %in% listaVizinhosSobrepostos){
            listaVizinhosSobrepostos = append(listaVizinhosSobrepostos, vizinhoAtual) ;
          }


        }else{
          #print('non overlaping');
          #print(pointX);
          #print(pointY);
          if(cor == 'green'){
            #points(pointX, pointY, col = "green", cex = 1.6);
            #cor = 'green';
          }

        }

        iteradorVizinhos = iteradorVizinhos +1;
      }

      iteradorPontosPoligono = iteradorPontosPoligono + 1;
      pontosTotaisSobrepostos = pontosTotaisSobrepostos + pontosSobrepostos;
    }

    # Fix the overlaping
    if(poligonoSobreposto == TRUE){

      iteradorVizinhosSobrepostos = 1;

      foreach(listaVizinhosSobrepostos)%do%{

        poligono = mapa@polygons[[iteradorElementosMapa]]@Polygons[[1]];
        vizinho = mapa@polygons[[listaVizinhosSobrepostos[iteradorVizinhosSobrepostos]]]@Polygons[[1]];
        idPoligonoVerificado = listaVizinhosSobrepostos;

        if(!is.null(poligono) && !is.null(vizinho)){

          countOverlap = countOverlap+1;

          poligonoAVerificar = poligono;
          poligonoVizinho = vizinho;
          idPoligonoVerificado = idPoligonoVerificado;

          poly1 <- Polygon(poligonoVizinho);
          poly2 <- Polygon(poligonoAVerificar);

          # create SpatialPolygons objects
          p1 <- SpatialPolygons(list(Polygons(list(poly1), "p1")));
          p2 <- SpatialPolygons(list(Polygons(list(poly2), "p2")));

          # Check if the polygon is control and use diferent aproaches to fix him
          if(controle$controle == 1){
            res <- gDifference(p1, p2);
          }
          else{
            res <- gDifference(p2, p1);
          }

          if(!is.null(res)){
            # Set the new values of the fixed polygon to the map
            mapa@polygons[[listaVizinhosSobrepostos[iteradorVizinhosSobrepostos]]]@Polygons[[1]]@coords = res@polygons[[1]]@Polygons[[1]]@coords;

          }
        }

        iteradorVizinhosSobrepostos = iteradorVizinhosSobrepostos + 1;
      }
    }

    iteradorElementosMapa=iteradorElementosMapa+1;

    setWinProgressBar(pb, iteradorElementosMapa, title=paste( round(iteradorElementosMapa/total*100, 0), "% done"))
  }

  close(pb)

  # Save the fixed shapefile to the especified directory
  writeOGR(mapa, dsn = pathToSave, layer = nameToSaveNewShapefile, driver = "ESRI Shapefile");

  # Returns the fixed shapefile
  return(mapa);
}
